//用于运行
//#define MAIN_CPP
#ifdef MAIN_CPP
#include <stdio.h> 

/*
 * 记(下面会用到)：
 *		两行长度都为n（即摆成一个矩形的方法数，也就是我们要求的结果）为：f(n)
 *		一行长度为n-1，另一行长度为n（即上下长度相差1，因为对称，无论第一行是n,还是第二行是n，都相同）为：g(n)
 * 
 * 考虑2 X n矩形最右上角的方块，有四种情况：
 *   OO   O   OO    O
 *        O    O   OO
 *   第一种情况：左边一个n-2的矩形，右边并排两个1X2，方法数是:f(n-2)
 *   第二种情况：左边一个n-1的矩形，右边一个2X1，方法数是:f(n-1)
 *   第三种和第四种情况是对称的：左边一个长度相差1的L矩形，右边一个L，方法数是:g(n-1)
 *   
 *   那么把一、二、三、四加起来是:f(n) = f(n-2)+f(n-1) + 2g(n-1)
 * 
 * 接下来就是求g(n)的递推公式了：
 *  不妨考虑第一行为n-1,第二行为n,考虑这个图形最右下的方块，有两种种情况：
 *       O
 *	 OO  OO
 *   第一种情况：左边一个长度相差1的倒L图形，右边一个1X2，方法数是:g(n-1)
 *   第二种情况：左边一个n-2的矩形，右边一个L图形，方法数是:f(n-2)
 *   
 *   那么把一、二加起来是:g(n) = f(n-2)+g(n-1)
 *   
 *  当然我们现在可以把上面两个递推公式连立，求通项公式，但我们中间的f(n-1),f(n-2）等等可能会被输出
 *		所以直接求出所有的值，然后，打表输出所有就行
 *   
 */

unsigned f[1000002];//两行长度都为n的方法数
unsigned g[1000002];//上下长度相差1的方法数

void caculate_f_g();//计算f和g

unsigned N;

int main()
{
	caculate_f_g();
	while (scanf("%u",&N) == 1)
		printf("%u\n",f[N]);
	return 0;
}

inline void caculate_f_g()
{
	f[0] = g[0] = g[1] = 0;
	f[1] = g[2] = 1;
	f[2] = 2;
	for(unsigned i =3;i<1000001;i++)
	{
		//直接按递推公式计算
		f[i] = (f[i - 2] + f[i - 1] + 2 * g[i - 1]) % 10000;
		g[i] = (f[i - 2] + g[i - 1]) % 10000;
	}
}

#endif
