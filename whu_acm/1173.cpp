//用于运行
//#define MAIN_CPP
#ifdef MAIN_CPP
#include <stdio.h> 

/*
 *当然用一个循环链表，就可以解决这个问题，但需要O(n)的空间，当n特别大的时候就不合适了
 * 
 * 这里我用数学方法来推导计算公式:
 *		总共为n个数在还剩下i个数的时候，从开始数的第一个数起，依次标号为1,2,3...i
 *		为表示方便我们标号为0指的是标号为最大的那个数（即i,方便用取模表示），记最后去掉的数记为k
 *		现在我们要解决的问题是，根据递归分治的思想：
 *			假设我们知道了在还剩下i个数的时候，最后去掉的数序号是k
 *			可以求出在还剩下还剩下i+1个数的时候，最后去掉的数序号是f(k,i) (说明，f(k)是关于k,i的函数)
 *			那么我们就可以根据剩下一个数的时候，最后去掉的数序号是k，一直推下去，推出剩下一个数的时候，最后去掉的数序号是r。
 *			而r就是我们要求的结果。
 *		
 *		现在的问题就是求出f(k,i)这个函数，让我们来考察下i+1个数去掉一个数变成i个数的过程：
 *		剩下i+1个数的时候，我们第一步去掉了序号是m%(i+1)的数，数字总数变成了i，现在这些数在原来剩i+1个数时的位置编号是
 *		**1**
 *			   1      2     3  ........     (m-1)%(i+1)     (m+1)%(i+1)  ....... i+1   
 *		
 *		变成i个数的时候是从第(m+1)%(i+1)个数开始数起的，那么在i个数的时候，它们在原来剩i+1个数时的位置编号：
 *		**2**
 *			 (m+1)%(i+1)     (m+2)%(i+1)   (m+3)%(i+1) ........     i+1   1 ..... (m-1)%(i+1)
 *		
 *		因为整个序列是循环的，所以上面的编号等价表示成与m % (i+1)的距离是：
 *		
 *		**3**
 *			 (m+1)%(i+1)     (m+2)%(i+1)   (m+3)%(i+1) ........     (m+i+1-m)%(i+1)   (m+i+2-m)%(i+1) ..... (m+i)%(i+1)    
 *		
 *		注意这里的(m+i+1-m)%(i+1)的结果是0,前文提到过，它表示的是 i+1
 *		
 *		即：
 *		**4**
 *				(m+k)%(i+1)  k=1,2,3...i 
 *		
 *		在剩下i个数的时候，它们的新编号为：
 *		**5**
 *			   1      2     3  ........   i-2   i-1   i 
 *		
 *		对比**5**和**3**，可以发现他们的对应关系就是**4**，结合前面的0的问题，写成函数是：
 *		即：f(k,i) = 
 *				(m+k)%(i+1)		当k!= i+1-m
 *				i+1				当k== i+1-m
 *
 *		这就是我们要求的f(k,i)
 */

unsigned n, m;//题意中n，m

unsigned get_last_num();//计算最后一个数

int main()
{
	while (scanf("%u %u",&n,&m) == 2)
	{
		if( n == 0)break;
		printf("%u\n", get_last_num());
	}
	return 0;
}

inline unsigned get_last_num()
{
	unsigned last_num = 1;
	for(unsigned i=1;i < n;i++)
	{
		/*
		 * 根据
		 *  f(k,i) = 
		 *				(m+k)%(i+1)		当k!= i+1-m
		 *				i+1				当k== i+1-m
		 *	计算
		 */
		last_num = (m + last_num) % (i + 1);
		if (last_num == 0) last_num = i + 1;
	}
	return last_num;
}

#endif
